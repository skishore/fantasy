"use strict";

Object.defineProperty(exports, "__esModule", { value: true });

const builtin_base_cases = {
  '?': (d) => null,
  '*': (d) => d,
  '+': (d) => d,
};
const builtin_recursives = {
  '?': (d) => d[0],
  '*': (d) => d[0].concat([d[1]]),
  '+': (d) => d[0].concat([d[1]]),
};

const lexer = require('../parsing/lexer');

exports.lexer = new lexer.MooLexer({
  block: {match: /{%[^]*?[%]}/, value: (x) => x.slice(2, -2).trim()},
  close: ')',
  comment: {match: /#.*$/, value: () => null},
  float: lexer.MooLexer.float,
  identifier: /[a-zA-Z_][a-zA-Z0-9_]*/,
  integer: lexer.MooLexer.integer,
  newline: '\n',
  string: lexer.MooLexer.string,
  whitespace: {match: /\s+/},
  _: /./,
});
exports.rules = [
  {lhs: "main$macro$1$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "main$macro$1$modifier$1$subexpression$1", rhs: ["b", "item"]},
  {lhs: "main$macro$1$modifier$1", rhs: ["main$macro$1$modifier$1", "main$macro$1$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "main$macro$1", rhs: ["item", "main$macro$1$modifier$1"], transform: (d) => [d[0]].concat(d[1].map((x) => x[1]))},
  {lhs: "main", rhs: ["_", "main$macro$1", "_"], transform: (d) => d[1]},
  {lhs: "item", rhs: [{text: "@"}, "_", {type: "block"}], transform: (d) => ({type: 'block', block: d[2]})},
  {lhs: "item", rhs: [{text: "@"}, {text: "lexer"}, "_", {type: "block"}], transform: (d) => ({type: 'lexer', lexer: d[3]})},
  {lhs: "item$macro$1$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "item$macro$1$modifier$1$subexpression$1", rhs: ["b", "rhs"]},
  {lhs: "item$macro$1$modifier$1", rhs: ["item$macro$1$modifier$1", "item$macro$1$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "item$macro$1", rhs: ["rhs", "item$macro$1$modifier$1"], transform: (d) => [d[0]].concat(d[1].map((x) => x[1]))},
  {lhs: "item", rhs: ["lhs", "directives", "_", "item$macro$1"], transform: (d) => ({type: 'rule', rule: {directives: d[1], lhs: d[0], rhs: d[3]}})},
  {lhs: "lhs$macro$1$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "lhs$macro$1$modifier$1$subexpression$1", rhs: ["c", "word"]},
  {lhs: "lhs$macro$1$modifier$1", rhs: ["lhs$macro$1$modifier$1", "lhs$macro$1$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "lhs$macro$1", rhs: ["word", "lhs$macro$1$modifier$1"], transform: (d) => [d[0]].concat(d[1].map((x) => x[1]))},
  {lhs: "lhs", rhs: ["word", {text: "["}, "lhs$macro$1", {text: "]"}], transform: (d) => ({type: 'macro', name: d[0], args: d[2]})},
  {lhs: "lhs$modifier$1", rhs: [], transform: builtin_base_cases['?']},
  {lhs: "lhs$modifier$1", rhs: [{text: "."}], transform: builtin_recursives['?']},
  {lhs: "lhs", rhs: ["lhs$modifier$1", "word"], transform: (d) => ({type: 'symbol', name: d[1], root: !!d[0]})},
  {lhs: "rhs$macro$1$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "rhs$macro$1$modifier$1$subexpression$1", rhs: [{text: " "}, "term"]},
  {lhs: "rhs$macro$1$modifier$1", rhs: ["rhs$macro$1$modifier$1", "rhs$macro$1$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "rhs$macro$1", rhs: ["term", "rhs$macro$1$modifier$1"], transform: (d) => [d[0]].concat(d[1].map((x) => x[1]))},
  {lhs: "rhs", rhs: ["s", {text: " "}, "rhs$macro$1", "directives"], transform: (d) => ({type: d[0], terms: d[2], directives: d[3]})},
  {lhs: "term$modifier$1", rhs: [], transform: builtin_base_cases['?']},
  {lhs: "term$modifier$1", rhs: [{text: "?"}], transform: builtin_recursives['?']},
  {lhs: "term", rhs: ["expr", "term$modifier$1", "m"], transform: (d) => ({type: 'expr', expr: d[0], mark: d[2], optional: !!d[1]})},
  {lhs: "term", rhs: [{type: "_"}], transform: (d) => ({type: 'punctuation', punctuation: d[0]})},
  {lhs: "expr", rhs: [{text: "@"}, "word"], transform: (d) => ({type: 'binding', name: d[1]})},
  {lhs: "expr$macro$1$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "expr$macro$1$modifier$1$subexpression$1", rhs: ["c", "expr"]},
  {lhs: "expr$macro$1$modifier$1", rhs: ["expr$macro$1$modifier$1", "expr$macro$1$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "expr$macro$1", rhs: ["expr", "expr$macro$1$modifier$1"], transform: (d) => [d[0]].concat(d[1].map((x) => x[1]))},
  {lhs: "expr", rhs: ["word", {text: "["}, "expr$macro$1", {text: "]"}], transform: (d) => ({type: 'macro', args: d[2], name: d[0]})},
  {lhs: "expr", rhs: [{text: "$"}, "word"], transform: (d) => ({type: 'term', term: d[1]})},
  {lhs: "expr", rhs: ["word"], transform: (d) => ({type: 'term', term: {text: d[0]}})},
  {lhs: "expr", rhs: [{text: "%"}, "word"], transform: (d) => ({type: 'term', term: {type: d[1]}})},
  {lhs: "word", rhs: [{type: "identifier"}], transform: (d) => d[0]},
  {lhs: "directives$modifier$1", rhs: [], transform: builtin_base_cases['*']},
  {lhs: "directives$modifier$1$subexpression$1", rhs: ["_", {text: "("}, "directive", {text: ")"}]},
  {lhs: "directives$modifier$1", rhs: ["directives$modifier$1", "directives$modifier$1$subexpression$1"], transform: builtin_recursives['*']},
  {lhs: "directives", rhs: ["directives$modifier$1"], transform: (d) => d[0].map((x) => x[2])},
  {lhs: "directive", rhs: [{text: ">"}, "_", "number"], transform: (d) => ({type: 'score-gen', score: d[2]})},
  {lhs: "directive", rhs: [{text: "<"}, "_", "number"], transform: (d) => ({type: 'score-par', score: d[2]})},
  {lhs: "directive$modifier$1", rhs: ["token"], transform: builtin_base_cases['+']},
  {lhs: "directive$modifier$1", rhs: ["directive$modifier$1", "token"], transform: builtin_recursives['+']},
  {lhs: "directive", rhs: [{text: "="}, "directive$modifier$1"], transform: (d) => ({type: 'template', template: d[1]})},
  {lhs: "number$subexpression$1", rhs: [{type: "float"}]},
  {lhs: "number$subexpression$1", rhs: [{type: "integer"}]},
  {lhs: "number", rhs: ["number$subexpression$1"], transform: (d) => d[0][0]},
  {lhs: "token", rhs: [{type: "string"}], transform: (d) => JSON.stringify(d[0])},
  {lhs: "token$subexpression$1", rhs: ["number"]},
  {lhs: "token$subexpression$1", rhs: ["w"]},
  {lhs: "token$subexpression$1", rhs: [{type: "identifier"}]},
  {lhs: "token$subexpression$1", rhs: [{type: "_"}]},
  {lhs: "token", rhs: ["token$subexpression$1"], transform: (d) => `${d[0][0]}`},
  {lhs: "b", rhs: ["_", {text: "\n"}, "_"], transform: (d) => null},
  {lhs: "c", rhs: [{text: ","}, {text: " "}], transform: (d) => null},
  {lhs: "m$subexpression$1", rhs: []},
  {lhs: "m$subexpression$1", rhs: [{text: "^"}]},
  {lhs: "m$subexpression$1", rhs: [{text: "*"}]},
  {lhs: "m", rhs: ["m$subexpression$1"], transform: (d) => d[0][0] || '-'},
  {lhs: "s$subexpression$1", rhs: [{text: "="}]},
  {lhs: "s$subexpression$1", rhs: [{text: "<"}]},
  {lhs: "s$subexpression$1", rhs: [{text: ">"}]},
  {lhs: "s", rhs: ["s$subexpression$1"], transform: (d) => d[0][0]},
  {lhs: "w$subexpression$1", rhs: [{type: "newline"}]},
  {lhs: "w$subexpression$1", rhs: [{type: "whitespace"}]},
  {lhs: "w", rhs: ["w$subexpression$1"], transform: (d) => d[0][0]},
  {lhs: "_$subexpression$1", rhs: []},
  {lhs: "_$subexpression$1", rhs: ["_", {type: "comment"}]},
  {lhs: "_$subexpression$1", rhs: ["_", "w"]},
  {lhs: "_", rhs: ["_$subexpression$1"], transform: (d) => null},
];
exports.start = "main";
